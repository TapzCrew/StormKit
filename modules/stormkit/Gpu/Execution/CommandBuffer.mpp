// Copyright (C) 2023 Arthur LAURENT <arthur.laurent4@gmail.com>
// This file is subject to the license terms in the LICENSE file
// found in the top-level of this distribution

module;

#include <stormkit/Core/HashMacro.hpp>
#include <stormkit/Core/PlatformMacro.hpp>

export module stormkit.Gpu:Execution.CommandBuffer;

import std;

import frozen;

import stormkit.Core;
import stormkit.Gpu.Vulkan;

import :Core;
import :Resource;
import :Execution.Descriptors;
import :Execution.RenderPass;
import :Execution.Pipeline;

export namespace stormkit::gpu {
    struct SubmitInfo {
        std::span<const Borrowed<const Semaphore>>     wait_semaphores   = {};
        std::span<const PipelineStageFlag>             wait_dst_stages   = {};
        std::span<const Borrowed<const CommandBuffer>> command_buffers   = {};
        std::span<const Borrowed<const Semaphore>>     signal_semaphores = {};
    };

    class STORMKIT_API Queue {
        struct Tag {};

      public:
        static constexpr auto DEBUG_TYPE = DebugObjectType::Queue;

        Queue(const Device& device, const Device::QueueEntry& entry, Tag);
        ~Queue();

        Queue(const Queue&)          = delete;
        auto operator=(const Queue&) = delete;

        Queue(Queue&&) noexcept;
        auto operator=(Queue&&) noexcept -> Queue&;

        [[nodiscard]] static auto
            create(const Device&             device,
                   const Device::QueueEntry& entry) noexcept -> Expected<Queue>;
        [[nodiscard]] static auto
            allocate(const Device&             device,
                     const Device::QueueEntry& entry) noexcept -> Expected<std::unique_ptr<Queue>>;

        auto waitIdle() const noexcept -> void;

        auto submit(std::span<const SubmitInfo> submit_infos,
                    MaybeBorrowed<const Fence>  fence = std::nullopt) const noexcept -> void;

        auto submit(const SubmitInfo&          submit_info,
                    MaybeBorrowed<const Fence> fence = std::nullopt) const noexcept -> void;

        [[nodiscard]] auto
            present(std::span<const Borrowed<const Swapchain>> swapchains,
                    std::span<const Borrowed<const Semaphore>> wait_semaphores,
                    std::span<const UInt32> image_indices) const noexcept -> Expected<gpu::Result>;

        [[nodiscard]] auto entry() const noexcept -> const Device::QueueEntry&;

        [[nodiscard]] auto vkHandle() const noexcept -> const vk::raii::Queue&;

      private:
        Device::QueueEntry m_entry;

        DeferInit<vk::raii::Queue> m_vk_queue;
    };

    class CommandPool;

    struct InheritanceInfo {
        const RenderPass*  render_pass = nullptr;
        UInt32             subpass     = 0;
        const FrameBuffer* framebuffer = nullptr;
    };

    template<typename T>
    concept IsImage = requires(T&& img) {
        img.extent();
        img.format();
        img.type();
        img.samples();
        img.layers();
        img.faces();
        img.mipLevels();
        img.usages();
        img.vkHandle();
    };

    class STORMKIT_API CommandBuffer {
        struct Tag {};

      public:
        enum class State {
            Initial,
            Recording,
            Executable
        };

        static constexpr auto DEBUG_TYPE = DebugObjectType::Command_Buffer;

        using Deleter = std::function<void(vk::raii::CommandBuffer&)>;
        CommandBuffer(const CommandPool&,
                      CommandBufferLevel,
                      vk::raii::CommandBuffer&&,
                      Deleter,
                      Tag);
        ~CommandBuffer();

        CommandBuffer(const CommandBuffer&)                    = delete;
        auto operator=(const CommandBuffer&) -> CommandBuffer& = delete;

        CommandBuffer(CommandBuffer&&) noexcept;
        auto operator=(CommandBuffer&&) noexcept -> CommandBuffer&;

        [[nodiscard]] static auto create(const CommandPool&,
                                         CommandBufferLevel,
                                         vk::raii::CommandBuffer&&,
                                         Deleter) noexcept -> CommandBuffer;
        [[nodiscard]] static auto allocate(const CommandPool&,
                                           CommandBufferLevel,
                                           vk::raii::CommandBuffer&&,
                                           Deleter) noexcept -> std::unique_ptr<CommandBuffer>;

        auto reset() noexcept -> void;
        auto submit(const Queue&                               queue,
                    std::span<const Borrowed<const Semaphore>> wait_semaphores   = {},
                    std::span<const PipelineStageFlag>         wait_dst_stages   = {},
                    std::span<const Borrowed<const Semaphore>> signal_semaphores = {},
                    MaybeBorrowed<const Fence> fence = std::nullopt) const noexcept -> void;

        [[nodiscard]] auto state() const noexcept -> State;
        [[nodiscard]] auto level() const noexcept -> CommandBufferLevel;

        auto beginDebugRegion(std::string_view name,
                              const RGBColorF& color = RGBColorDef::White<float>) -> void;
        auto insertDebugLabel(std::string_view name,
                              const RGBColorF& color = RGBColorDef::White<float>) -> void;
        auto endDebugRegion() -> void;

        auto begin(bool                           one_time_submit  = false,
                   std::optional<InheritanceInfo> inheritance_info = std::nullopt) -> void;
        auto end() -> void;

        auto beginRenderPass(const RenderPass&           render_pass,
                             const FrameBuffer&          framebuffer,
                             std::span<const ClearValue> clear_values = std::array { ClearValue {
                                 ClearColor { .color = RGBColorDef::Silver<float> } } },
                             bool                        secondary_commandbuffers = false) -> void;
        auto nextSubPass() -> void;
        auto endRenderPass() -> void;

        auto bindPipeline(const Pipeline& pipeline) -> void;
        auto setViewport(UInt32 first_viewport, std::span<const Viewport> viewports) -> void;
        auto setScissor(UInt32 first_scissor, std::span<const Scissor> scissors) -> void;
        auto setLineWidth(float width) -> void;
        auto setDepthBias(float constant_factor, float clamp, float slope_factor) -> void;
        auto setBlendConstants(std::span<const float> constants) -> void;
        auto setDepthBounds(float min, float max) -> void;
        auto setStencilCompareMask(StencilFaceFlag face, UInt32 mask) -> void;
        auto setStencilWriteMask(StencilFaceFlag face, UInt32 mask) -> void;
        auto setStencilReference(StencilFaceFlag face, UInt32 reference) -> void;

        auto dispatch(UInt32 group_count_x, UInt32 group_count_y, UInt32 group_count_z) -> void;

        auto draw(UInt32 vertex_count,
                  UInt32 instance_count = 1u,
                  UInt32 first_vertex   = 0,
                  UInt32 first_instance = 0) -> void;
        auto drawIndexed(UInt32 index_count,
                         UInt32 instance_count = 1u,
                         UInt32 first_index    = 0u,
                         Int32  vertex_offset  = 0,
                         UInt32 first_instance = 0u) -> void;
        auto drawIndirect(const Buffer& buffer,
                          RangeExtent   offset,
                          UInt32        draw_count,
                          UInt32        stride) -> void;
        auto drawIndexedIndirect(const Buffer& buffer,
                                 RangeExtent   offset,
                                 UInt32        draw_count,
                                 UInt32        stride) -> void;

        auto bindVertexBuffers(std::span<Borrowed<const Buffer>> buffers,
                               std::span<const UInt64>           offsets) -> void;
        auto bindIndexBuffer(const Buffer& buffer,
                             UInt64        offset        = 0,
                             bool          large_indices = false) -> void;
        auto bindDescriptorSets(const Pipeline&                          pipeline,
                                const PipelineLayout&                    layout,
                                std::span<Borrowed<const DescriptorSet>> descriptor_sets,
                                std::span<const UInt32> dynamic_offsets = {}) -> void;

        auto copyBuffer(const Buffer& src,
                        const Buffer& dst,
                        RangeExtent   size,
                        UInt64        src_offset = 0u,
                        UInt64        dst_offset = 0u) -> void;
        auto copyBufferToImage(const Buffer&                    src,
                               const IsImage auto&              dst,
                               std::span<const BufferImageCopy> buffer_image_copies = {}) -> void;
        auto copyImageToBuffer(const IsImage auto&              src,
                               const Buffer&                    dst,
                               std::span<const BufferImageCopy> buffer_image_copies = {}) -> void;
        auto copyImage(const IsImage auto&           src,
                       const IsImage auto&           dst,
                       ImageLayout                   src_layout,
                       ImageLayout                   dst_layout,
                       const ImageSubresourceLayers& src_subresource_layers,
                       const ImageSubresourceLayers& dst_subresource_layers,
                       const math::ExtentU&          extent) -> void;

        auto resolveImage(const IsImage auto&           src,
                          const IsImage auto&           dst,
                          ImageLayout                   src_layout,
                          ImageLayout                   dst_layout,
                          const ImageSubresourceLayers& src_subresource_layers = {},
                          const ImageSubresourceLayers& dst_subresource_layers = {}) -> void;

        auto blitImage(const IsImage auto&         src,
                       const IsImage auto&         dst,
                       ImageLayout                 src_layout,
                       ImageLayout                 dst_layout,
                       std::span<const BlitRegion> regions,
                       Filter                      filter) -> void;

        auto transitionImageLayout(const IsImage auto&          image,
                                   ImageLayout                  src_layout,
                                   ImageLayout                  dst_layout,
                                   const ImageSubresourceRange& subresource_range = {}) -> void;

        auto executeSubCommandBuffers(std::span<const Borrowed<const CommandBuffer>> commandbuffers)
            -> void;

        auto pipelineBarrier(PipelineStageFlag                    src_mask,
                             PipelineStageFlag                    dst_mask,
                             DependencyFlag                       dependency,
                             std::span<const MemoryBarrier>       memory_barriers,
                             std::span<const BufferMemoryBarrier> buffer_memory_barriers,
                             std::span<const ImageMemoryBarrier>  image_memory_barriers) -> void;

        auto pushConstants(const PipelineLayout& pipeline_layout,
                           ShaderStageFlag       stage,
                           std::span<const Byte> data,
                           UInt32                offset = 0u) -> void;

        [[nodiscard]] auto vkHandle() const noexcept -> const vk::raii::CommandBuffer&;

      private:
        CommandBufferLevel m_level = CommandBufferLevel::Primary;

        vk::raii::CommandBuffer m_vk_command_buffer;

        Deleter m_deleter;

        State m_state = State::Initial;
    };

    class STORMKIT_API CommandPool {
        struct Tag {};

      public:
        CommandPool(const Device& device, const Queue& queue, Tag);
        ~CommandPool();

        CommandPool(const CommandPool&)    = delete;
        auto operator=(const CommandPool&) = delete;

        CommandPool(CommandPool&&) noexcept;
        auto operator=(CommandPool&&) noexcept -> CommandPool&;

        [[nodiscard]] static auto create(const Device& device,
                                         const Queue&  queue) noexcept -> Expected<CommandPool>;
        [[nodiscard]] static auto allocate(const Device& device, const Queue& queue) noexcept
            -> Expected<std::unique_ptr<CommandPool>>;

        [[nodiscard]] auto createCommandBuffer(
            const Device&      device,
            CommandBufferLevel level = CommandBufferLevel::Primary) const noexcept -> CommandBuffer;
        [[nodiscard]] auto
            createCommandBuffers(const Device&      device,
                                 RangeExtent        count,
                                 CommandBufferLevel level = CommandBufferLevel::Primary)
                const noexcept -> std::vector<CommandBuffer>;

        [[nodiscard]] auto
            allocateCommandBuffer(const Device&      device,
                                  CommandBufferLevel level = CommandBufferLevel::Primary)
                const noexcept -> std::unique_ptr<CommandBuffer>;
        [[nodiscard]] auto
            allocateCommandBuffers(const Device&      device,
                                   RangeExtent        count,
                                   CommandBufferLevel level = CommandBufferLevel::Primary)
                const noexcept -> std::vector<std::unique_ptr<CommandBuffer>>;

        [[nodiscard]] auto vkHandle() const noexcept -> const vk::raii::CommandPool&;

      private:
        auto createVkCommandBuffers(const Device&      device,
                                    RangeExtent        count,
                                    CommandBufferLevel level) const noexcept
            -> std::vector<vk::raii::CommandBuffer>;
        auto deleteVkCommandBuffer(vk::raii::CommandBuffer& cmb) noexcept -> void;

        DeferInit<vk::raii::CommandPool> m_vk_command_pool;

        // std::mutex                           m_reuse_mutex;
        std::vector<vk::raii::CommandBuffer> m_reusable_command_buffers;
    };
} // namespace stormkit::gpu

////////////////////////////////////////////////////////////////////
///                      IMPLEMENTATION                          ///
////////////////////////////////////////////////////////////////////

namespace stormkit::gpu {
    namespace {
        constexpr auto old_layout_access_map =
            frozen::make_unordered_map<vk::ImageLayout,
                                       std::pair<vk::AccessFlags, vk::PipelineStageFlags>>(
                { { vk::ImageLayout::eUndefined,
                    { vk::AccessFlagBits {}, vk::PipelineStageFlagBits::eTopOfPipe } },
                  { vk::ImageLayout::ePreinitialized,
                    { vk::AccessFlagBits {}, vk::PipelineStageFlagBits::eTopOfPipe } },
                  { vk::ImageLayout::eGeneral,
                    { vk::AccessFlagBits::eColorAttachmentWrite |
                          vk::AccessFlagBits::eColorAttachmentRead,
                      vk::PipelineStageFlagBits::eColorAttachmentOutput } },
                  { vk::ImageLayout::eColorAttachmentOptimal,
                    { vk::AccessFlagBits::eColorAttachmentWrite |
                          vk::AccessFlagBits::eColorAttachmentRead,
                      vk::PipelineStageFlagBits::eColorAttachmentOutput } },
                  { vk::ImageLayout::eDepthStencilAttachmentOptimal,
                    { vk::AccessFlagBits::eDepthStencilAttachmentRead |
                          vk::AccessFlagBits::eDepthStencilAttachmentWrite,
                      vk::PipelineStageFlagBits::eLateFragmentTests } },
                  { vk::ImageLayout::eDepthStencilReadOnlyOptimal,
                    { vk::AccessFlagBits::eDepthStencilAttachmentRead,
                      vk::PipelineStageFlagBits::eLateFragmentTests } },
                  { vk::ImageLayout::eShaderReadOnlyOptimal,
                    { vk::AccessFlagBits::eInputAttachmentRead,
                      vk::PipelineStageFlagBits::eFragmentShader } },
                  { vk::ImageLayout::eTransferSrcOptimal,
                    { vk::AccessFlagBits::eTransferRead, vk::PipelineStageFlagBits::eTransfer } },
                  { vk::ImageLayout::eTransferDstOptimal,
                    { vk::AccessFlagBits::eTransferWrite, vk::PipelineStageFlagBits::eTransfer } },
                  { vk::ImageLayout::ePresentSrcKHR,
                    { vk::AccessFlagBits::eMemoryRead, vk::PipelineStageFlagBits::eTransfer } } });

        constexpr auto new_layout_access_map =
            frozen::make_unordered_map<vk::ImageLayout,
                                       std::pair<vk::AccessFlags, vk::PipelineStageFlags>>(
                { { vk::ImageLayout::eUndefined, { vk::AccessFlagBits {}, {} } },
                  { vk::ImageLayout::ePreinitialized, { vk::AccessFlagBits {}, {} } },
                  { vk::ImageLayout::eGeneral,
                    { vk::AccessFlagBits::eShaderWrite | vk::AccessFlagBits::eShaderRead,
                      vk::PipelineStageFlagBits::eVertexShader } },
                  { vk::ImageLayout::eColorAttachmentOptimal,
                    { vk::AccessFlagBits::eColorAttachmentWrite |
                          vk::AccessFlagBits::eColorAttachmentRead,
                      vk::PipelineStageFlagBits::eColorAttachmentOutput } },
                  { vk::ImageLayout::eDepthStencilAttachmentOptimal,
                    { vk::AccessFlagBits::eDepthStencilAttachmentWrite |
                          vk::AccessFlagBits::eDepthStencilAttachmentRead,
                      vk::PipelineStageFlagBits::eEarlyFragmentTests } },
                  { vk::ImageLayout::eDepthStencilReadOnlyOptimal,
                    { vk::AccessFlagBits::eShaderRead, vk::PipelineStageFlagBits::eVertexInput } },
                  { vk::ImageLayout::eShaderReadOnlyOptimal,
                    { vk::AccessFlagBits::eShaderRead,
                      vk::PipelineStageFlagBits::eFragmentShader } },
                  { vk::ImageLayout::eTransferSrcOptimal,
                    { vk::AccessFlagBits::eTransferRead, vk::PipelineStageFlagBits::eTransfer } },
                  { vk::ImageLayout::eTransferDstOptimal,
                    { vk::AccessFlagBits::eTransferWrite, vk::PipelineStageFlagBits::eTransfer } },
                  { vk::ImageLayout::ePresentSrcKHR,
                    { vk::AccessFlagBits::eMemoryRead, vk::PipelineStageFlagBits::eTransfer } } });
    } // namespace

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE Queue::Queue(const Device& device, const Device::QueueEntry& entry, Tag)
        : m_entry { entry } {
        toRaiiVkHandle(device)
            .getQueue(entry.id, 0)
            .transform(core::monadic::set(m_vk_queue))
            .transform_error(core::monadic::map(core::monadic::as<Result>(), throwError()));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE Queue::~Queue() = default;

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE Queue::Queue(Queue&&) noexcept = default;

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto Queue::operator=(Queue&&) noexcept -> Queue& = default;

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto
        Queue::create(const Device&             device,
                      const Device::QueueEntry& entry) noexcept -> Expected<Queue> try {
        return Queue { device, entry, Tag {} };
    } catch (const Result& result) { return std::unexpected(result); }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto Queue::allocate(const Device&             device,
                                               const Device::QueueEntry& entry) noexcept
        -> Expected<std::unique_ptr<Queue>> try {
        return std::make_unique<Queue>(device, entry, Tag {});
    } catch (const Result& result) { return std::unexpected(result); }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto Queue::waitIdle() const noexcept -> void {
        m_vk_queue->waitIdle();
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto
        Queue::submit(std::span<const SubmitInfo> submit_infos,
                      MaybeBorrowed<const Fence>  fence) const noexcept -> void {
        struct Storage {
            std::vector<vk::Semaphore>          wait_semaphores   = {};
            std::vector<vk::PipelineStageFlags> wait_dst_stages   = {};
            std::vector<vk::CommandBuffer>      command_buffers   = {};
            std::vector<vk::Semaphore>          signal_semaphores = {};
        };

        auto storages = std::vector<Storage> {};
        storages.reserve(std::size(submit_infos));

        // clang-format off
        const auto vk_submit_infos = submit_infos
        | std::views::transform([&storages](auto &&submit_info) noexcept {
           core::expects(std::size(submit_info.wait_semaphores) == std::size(submit_info.wait_dst_stages));

           const auto &storage = storages.emplace_back(Storage {
             .wait_semaphores = submit_info.wait_semaphores 
                  | std::views::transform(monadic::toVkHandle())
                  | std::ranges::to<std::vector>(),
             .wait_dst_stages = submit_info.wait_dst_stages
                  | std::views::transform(monadic::toVkFlags<vk::PipelineStageFlagBits>())
                  | std::ranges::to<std::vector>(),
             .command_buffers = submit_info.command_buffers 
                  | std::views::transform(monadic::toVkHandle())
                  | std::ranges::to<std::vector>(),
             .signal_semaphores = submit_info.signal_semaphores 
                  | std::views::transform(monadic::toVkHandle())
                  | std::ranges::to<std::vector>()
           });

           return vk::SubmitInfo{}
               .setWaitSemaphores(storage.wait_semaphores)
               .setWaitDstStageMask(storage.wait_dst_stages)
               .setCommandBuffers(storage.command_buffers)
               .setSignalSemaphores(storage.signal_semaphores);
        })
        | std::ranges::to<std::vector>();
        // clang-format on

        const auto vk_fence =
            core::either(fence, monadic::toVkHandle(), core::monadic::init<vk::Fence>(nullptr));

        vkHandle().submit(vk_submit_infos, vk_fence);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto
        Queue::submit(const SubmitInfo&          submit_info,
                      MaybeBorrowed<const Fence> fence) const noexcept -> void {
        submit({ &submit_info, 1 }, std::move(fence));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    auto Queue::present(std::span<const Borrowed<const Swapchain>> swapchains,
                        std::span<const Borrowed<const Semaphore>> wait_semaphores,
                        std::span<const UInt32>                    image_indices) const noexcept
        -> Expected<gpu::Result> {
        expects(std::size(wait_semaphores) >= 1);
        expects(std::size(image_indices) >= 1);
        const auto vk_wait_semaphores = wait_semaphores |
                                        std::views::transform(monadic::toVkHandle()) |
                                        std::ranges::to<std::vector>();
        const auto vk_swapchains = swapchains | std::views::transform(monadic::toVkHandle()) |
                                   std::ranges::to<std::vector>();
        const auto present_info = vk::PresentInfoKHR {}
                                      .setWaitSemaphores(vk_wait_semaphores)
                                      .setSwapchains(vk_swapchains)
                                      .setImageIndices(image_indices);

        const auto result           = m_vk_queue->presentKHR(present_info);
        const auto possible_results = std::array { vk::Result::eSuccess,
                                                   vk::Result::eErrorOutOfDateKHR,
                                                   vk::Result::eSuboptimalKHR };

        if (not std::ranges::any_of(possible_results, core::monadic::is(result))) [[likely]]
            return std::unexpected { narrow<gpu::Result>(result) };

        return narrow<gpu::Result>(result);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto Queue::entry() const noexcept -> const Device::QueueEntry& {
        return m_entry;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto Queue::vkHandle() const noexcept -> const vk::raii::Queue& {
        return m_vk_queue.get();
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE CommandBuffer::CommandBuffer(const CommandPool&        command_pool,
                                                       CommandBufferLevel        level,
                                                       vk::raii::CommandBuffer&& command_buffer,
                                                       Deleter                   deleter,
                                                       Tag)
        : m_level { level }, m_vk_command_buffer { std::move(command_buffer) },
          m_deleter { std::move(deleter) } {
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto CommandBuffer::create(const CommandPool&        pool,
                                                     CommandBufferLevel        level,
                                                     vk::raii::CommandBuffer&& cmb,
                                                     Deleter deleter) noexcept -> CommandBuffer {
        return CommandBuffer { pool, level, std::move(cmb), std::move(deleter), Tag {} };
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto
        CommandBuffer::allocate(const CommandPool&        pool,
                                CommandBufferLevel        level,
                                vk::raii::CommandBuffer&& cmb,
                                Deleter deleter) noexcept -> std::unique_ptr<CommandBuffer> {
        return std::make_unique<CommandBuffer>(pool,
                                               level,
                                               std::move(cmb),
                                               std::move(deleter),
                                               Tag {});
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE CommandBuffer::~CommandBuffer() = default;

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE CommandBuffer::CommandBuffer(CommandBuffer&&) noexcept = default;

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto
        CommandBuffer::operator=(CommandBuffer&&) noexcept -> CommandBuffer& = default;

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto CommandBuffer::reset() noexcept -> void {
        vkHandle().reset(vk::CommandBufferResetFlagBits {});
        m_state = State::Initial;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    auto CommandBuffer::submit(const Queue&                               queue,
                               std::span<const Borrowed<const Semaphore>> wait_semaphores,
                               std::span<const PipelineStageFlag>         wait_dst_stages,
                               std::span<const Borrowed<const Semaphore>> signal_semaphores,
                               MaybeBorrowed<const Fence> fence) const noexcept -> void {
        auto cmbs = borrows<std::array>(*this);

        queue.submit(std::array { SubmitInfo { .wait_semaphores   = wait_semaphores,
                                               .wait_dst_stages   = wait_dst_stages,
                                               .command_buffers   = cmbs,
                                               .signal_semaphores = signal_semaphores } },
                     std::move(fence));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto CommandBuffer::state() const noexcept -> State {
        return m_state;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto CommandBuffer::level() const noexcept -> CommandBufferLevel {
        return m_level;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto CommandBuffer::beginDebugRegion(std::string_view name,
                                                               const RGBColorF& color) -> void {
        expects(m_state == State::Recording);

        const auto& dispatcher = m_vk_command_buffer.getDispatcher();
        if (not dispatcher->vkCmdBeginDebugUtilsLabelEXT) [[unlikely]]
            return;

        const auto payload =
            vk::DebugUtilsLabelEXT {}.setPLabelName(std::data(name)).setColor(color);

        m_vk_command_buffer.beginDebugUtilsLabelEXT(payload);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto CommandBuffer::insertDebugLabel(std::string_view name,
                                                               const RGBColorF& color) -> void {
        expects(m_state == State::Recording);

        const auto& dispatcher = m_vk_command_buffer.getDispatcher();
        if (not dispatcher->vkCmdInsertDebugUtilsLabelEXT) [[unlikely]]
            return;

        const auto payload =
            vk::DebugUtilsLabelEXT {}.setPLabelName(std::data(name)).setColor(color);

        m_vk_command_buffer.insertDebugUtilsLabelEXT(payload);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto CommandBuffer::endDebugRegion() -> void {
        expects(m_state == State::Recording);

        const auto& dispatcher = m_vk_command_buffer.getDispatcher();
        if (not dispatcher->vkCmdEndDebugUtilsLabelEXT) [[unlikely]]
            return;

        m_vk_command_buffer.endDebugUtilsLabelEXT();
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto
        CommandBuffer::begin(bool                           one_time_submit,
                             std::optional<InheritanceInfo> inheritance_info) -> void {
        expects(m_state == State::Initial);

        const auto vk_inheritance_info = either(
            inheritance_info,
            [](auto&& inheritance_info) static noexcept {
                return vk::CommandBufferInheritanceInfo {}
                    .setRenderPass(toVkHandle(inheritance_info.render_pass))
                    .setSubpass(inheritance_info.subpass)
                    .setFramebuffer(toVkHandle(inheritance_info.framebuffer));
            },
            core::monadic::init<vk::CommandBufferInheritanceInfo>());

        const auto flags = [this, one_time_submit]() {
            auto flags = vk::CommandBufferUsageFlagBits::eOneTimeSubmit;

            if (!one_time_submit) flags = vk::CommandBufferUsageFlagBits::eSimultaneousUse;
            if (m_level == CommandBufferLevel::Secondary)
                return vk::CommandBufferUsageFlagBits::eRenderPassContinue;

            return flags;
        }();

        const auto begin_info =
            vk::CommandBufferBeginInfo {}.setFlags(flags).setPInheritanceInfo(&vk_inheritance_info);

        m_vk_command_buffer.begin(begin_info);

        m_state = State::Recording;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto CommandBuffer::end() -> void {
        expects(m_state == State::Recording);

        m_vk_command_buffer.end();
        m_state = State::Executable;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto
        CommandBuffer::beginRenderPass(const RenderPass&           render_pass,
                                       const FrameBuffer&          framebuffer,
                                       std::span<const ClearValue> clear_values,
                                       bool secondary_commandbuffers) -> void {
        expects(m_state == State::Recording);

        const auto vk_clear_values =
            clear_values |
            std::views::transform(core::monadic::either(
                [](const ClearColor& color) noexcept -> decltype(auto) {
                    return vk::ClearValue { .color = vk::ClearColorValue {
                                                .float32 =
                                                    color.color.operator std::array<float, 4>() } };
                },
                [](const ClearDepthStencil& depth_stencil) noexcept -> decltype(auto) {
                    return vk::ClearValue { .depthStencil = vk::ClearDepthStencilValue {
                                                .depth   = depth_stencil.depth,
                                                .stencil = depth_stencil.stencil } };
                })) |
            std::ranges::to<std::vector>();

        const auto begin_info =
            vk::RenderPassBeginInfo {}
                .setRenderPass(toVkHandle(render_pass))
                .setFramebuffer(toVkHandle(framebuffer))
                .setRenderArea(vk::Rect2D {}.setOffset({ 0, 0 }).setExtent(
                    { framebuffer.extent().width, framebuffer.extent().height }))
                .setClearValues(vk_clear_values);

        const auto subpass_content = secondary_commandbuffers
                                         ? vk::SubpassContents::eSecondaryCommandBuffers
                                         : vk::SubpassContents::eInline;

        m_vk_command_buffer.beginRenderPass(begin_info, subpass_content);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto CommandBuffer::nextSubPass() -> void {
        expects(m_state == State::Recording);

        m_vk_command_buffer.nextSubpass(vk::SubpassContents::eInline);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto CommandBuffer::endRenderPass() -> void {
        expects(m_state == State::Recording);

        m_vk_command_buffer.endRenderPass();
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto CommandBuffer::bindPipeline(const Pipeline& pipeline) -> void {
        expects(m_state == State::Recording);

        const auto bind_point = (pipeline.type() == Pipeline::Type::Raster)
                                    ? vk::PipelineBindPoint::eGraphics
                                    : vk::PipelineBindPoint::eCompute;

        m_vk_command_buffer.bindPipeline(bind_point, toVkHandle(pipeline));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto
        CommandBuffer::setViewport(UInt32                    first_viewport,
                                   std::span<const Viewport> viewports) -> void {
        expects(m_state == State::Recording);

        const auto vk_viewports = viewports |
                                  std::views::transform(core::monadic::as<vk::Viewport>()) |
                                  std::ranges::to<std::vector>();

        m_vk_command_buffer.setViewport(first_viewport, vk_viewports);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto
        CommandBuffer::setScissor(UInt32 first_scissor, std::span<const Scissor> scissors) -> void {
        expects(m_state == State::Recording);

        const auto vk_scissors = scissors | std::views::transform(core::monadic::as<vk::Rect2D>()) |
                                 std::ranges::to<std::vector>();

        m_vk_command_buffer.setScissor(first_scissor, vk_scissors);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto CommandBuffer::setLineWidth(float width) -> void {
        expects(m_state == State::Recording);

        m_vk_command_buffer.setLineWidth(width);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto CommandBuffer::setDepthBias(float constant_factor,
                                                           float clamp,
                                                           float slope_factor) -> void {
        expects(m_state == State::Recording);

        m_vk_command_buffer.setDepthBias(constant_factor, clamp, slope_factor);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto
        CommandBuffer::setBlendConstants(std::span<const float> constants) -> void {
        expects(m_state == State::Recording);

        float data[] = { constants[0], constants[1], constants[2], constants[3] };

        m_vk_command_buffer.setBlendConstants(data);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto CommandBuffer::setDepthBounds(float min, float max) -> void {
        expects(m_state == State::Recording);

        m_vk_command_buffer.setDepthBounds(min, max);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto CommandBuffer::setStencilCompareMask(StencilFaceFlag face,
                                                                    UInt32          mask) -> void {
        expects(m_state == State::Recording);

        m_vk_command_buffer.setStencilCompareMask(narrow<vk::StencilFaceFlagBits>(face), mask);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto CommandBuffer::setStencilWriteMask(StencilFaceFlag face,
                                                                  UInt32          mask) -> void {
        expects(m_state == State::Recording);

        m_vk_command_buffer.setStencilWriteMask(narrow<vk::StencilFaceFlagBits>(face), mask);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto CommandBuffer::setStencilReference(StencilFaceFlag face,
                                                                  UInt32 reference) -> void {
        expects(m_state == State::Recording);

        m_vk_command_buffer.setStencilReference(narrow<vk::StencilFaceFlagBits>(face), reference);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto CommandBuffer::dispatch(UInt32 group_count_x,
                                                       UInt32 group_count_y,
                                                       UInt32 group_count_z) -> void {
        expects(m_state == State::Recording);

        m_vk_command_buffer.dispatch(group_count_x, group_count_y, group_count_z);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto CommandBuffer::draw(UInt32 vertex_count,
                                                   UInt32 instance_count,
                                                   UInt32 first_vertex,
                                                   UInt32 first_instance) -> void {
        expects(m_state == State::Recording);
        expects(vertex_count > 0);

        m_vk_command_buffer.draw(vertex_count, instance_count, first_vertex, first_instance);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto CommandBuffer::drawIndexed(UInt32 index_count,
                                                          UInt32 instance_count,
                                                          UInt32 first_index,
                                                          Int32  vertex_offset,
                                                          UInt32 first_instance) -> void {
        expects(m_state == State::Recording);
        expects(index_count > 0);

        m_vk_command_buffer.drawIndexed(index_count,
                                        instance_count,
                                        first_index,
                                        vertex_offset,
                                        first_instance);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto CommandBuffer::drawIndirect(const Buffer& buffer,
                                                           RangeExtent   offset,
                                                           UInt32        draw_count,
                                                           UInt32        stride) -> void {
        expects(m_state == State::Recording);
        expects(draw_count > 0);

        m_vk_command_buffer.drawIndirect(toVkHandle(buffer), offset, draw_count, stride);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto CommandBuffer::drawIndexedIndirect(const Buffer& buffer,
                                                                  RangeExtent   offset,
                                                                  UInt32        draw_count,
                                                                  UInt32        stride) -> void {
        expects(m_state == State::Recording);
        expects(draw_count > 0);

        m_vk_command_buffer.drawIndexedIndirect(toVkHandle(buffer), offset, draw_count, stride);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto
        CommandBuffer::bindVertexBuffers(std::span<Borrowed<const Buffer>> buffers,
                                         std::span<const UInt64>           offsets) -> void {
        expects(m_state == State::Recording);
        expects(not std::empty(buffers));
        expects(std::size(buffers) == std::size(offsets));

        const auto vk_buffers =
            buffers | std::views::transform(monadic::toVkHandle()) | std::ranges::to<std::vector>();

        m_vk_command_buffer.bindVertexBuffers(0, vk_buffers, offsets);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto CommandBuffer::bindIndexBuffer(const Buffer& buffer,
                                                              UInt64        offset,
                                                              bool          large_indices) -> void {
        expects(m_state == State::Recording);

        m_vk_command_buffer.bindIndexBuffer(toVkHandle(buffer),
                                            offset,
                                            (large_indices) ? vk::IndexType::eUint16
                                                            : vk::IndexType::eUint32);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto
        CommandBuffer::bindDescriptorSets(const Pipeline&                          pipeline,
                                          const PipelineLayout&                    layout,
                                          std::span<Borrowed<const DescriptorSet>> descriptor_sets,
                                          std::span<const UInt32> dynamic_offsets) -> void {
        expects(m_state == State::Recording);

        const auto bind_point = (pipeline.type() == Pipeline::Type::Raster)
                                    ? vk::PipelineBindPoint::eGraphics
                                    : vk::PipelineBindPoint::eCompute;

        const auto vk_descriptor_sets = descriptor_sets |
                                        std::views::transform(monadic::toVkHandle()) |
                                        std::ranges::to<std::vector>();

        m_vk_command_buffer.bindDescriptorSets(bind_point,
                                               toVkHandle(layout),
                                               0,
                                               vk_descriptor_sets,
                                               dynamic_offsets);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto CommandBuffer::copyBuffer(const Buffer& src,
                                                         const Buffer& dst,
                                                         RangeExtent   size,
                                                         UInt64        src_offset,
                                                         UInt64        dst_offset) -> void {
        const auto vk_copy_buffers = std::array {
            vk::BufferCopy { .srcOffset = src_offset, .dstOffset = dst_offset, .size = size }
        };

        m_vk_command_buffer.copyBuffer(toVkHandle(src), toVkHandle(dst), vk_copy_buffers);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto CommandBuffer::copyBufferToImage(
        const Buffer&                    src,
        const IsImage auto&              dst,
        std::span<const BufferImageCopy> buffer_image_copies) -> void {
        expects(m_state == State::Recording);

        const auto DEFAULT_COPY =
            std::array { BufferImageCopy { 0, 0, 0, {}, { 0, 0, 0 }, dst.extent() } };

        if (std::empty(buffer_image_copies)) buffer_image_copies = DEFAULT_COPY;

        const auto vk_copy_regions =
            buffer_image_copies | std::views::transform([](auto&& buffer_image_copy) noexcept {
                const auto image_subresource = vk::ImageSubresourceLayers {
                    .aspectMask = narrow<vk::ImageAspectFlagBits>(
                        buffer_image_copy.subresource_layers.aspect_mask),
                    .mipLevel       = buffer_image_copy.subresource_layers.mip_level,
                    .baseArrayLayer = buffer_image_copy.subresource_layers.base_array_layer,
                    .layerCount     = buffer_image_copy.subresource_layers.layer_count,
                };

                return vk::BufferImageCopy {
                    .bufferOffset      = buffer_image_copy.buffer_offset,
                    .bufferRowLength   = buffer_image_copy.buffer_row_length,
                    .bufferImageHeight = buffer_image_copy.buffer_image_height,
                    .imageSubresource  = image_subresource,
                    .imageOffset       = as<vk::Offset3D>(buffer_image_copy.offset),
                    .imageExtent       = as<vk::Extent3D>(buffer_image_copy.extent)
                };
            }) |
            std::ranges::to<std::vector>();

        m_vk_command_buffer.copyBufferToImage(toVkHandle(src),
                                              toVkHandle(dst),
                                              vk::ImageLayout::eTransferDstOptimal,
                                              vk_copy_regions);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto CommandBuffer::copyImageToBuffer(
        const IsImage auto&              src,
        const Buffer&                    dst,
        std::span<const BufferImageCopy> buffer_image_copies) -> void {
        expects(m_state == State::Recording);

        const auto DEFAULT_COPY =
            std::array { BufferImageCopy { 0, 0, 0, {}, { 0, 0, 0 }, src.extent() } };

        if (std::empty(buffer_image_copies)) buffer_image_copies = DEFAULT_COPY;

        const auto vk_copy_regions =
            buffer_image_copies | std::views::transform([](auto&& buffer_image_copy) noexcept {
                const auto image_subresource = vk::ImageSubresourceLayers {
                    .aspectMask = narrow<vk::ImageAspectFlagBits>(
                        buffer_image_copy.subresource_layers.aspect_mask),
                    .mipLevel       = buffer_image_copy.subresource_layers.mip_level,
                    .baseArrayLayer = buffer_image_copy.subresource_layers.base_array_layer,
                    .layerCount     = buffer_image_copy.subresource_layers.layer_count,
                };

                return vk::BufferImageCopy {
                    .bufferOffset      = buffer_image_copy.buffer_offset,
                    .bufferRowLength   = buffer_image_copy.buffer_row_length,
                    .bufferImageHeight = buffer_image_copy.buffer_image_height,
                    .imageSubresource  = image_subresource,
                    .imageOffset       = as<vk::Offset3D>(buffer_image_copy.offset),
                    .imageExtent       = as<vk::Extent3D>(buffer_image_copy.extent)
                };
            }) |
            std::ranges::to<std::vector>();

        m_vk_command_buffer.copyImageToBuffer(toVkHandle(src),
                                              vk::ImageLayout::eTransferDstOptimal,
                                              toVkHandle(dst),
                                              vk_copy_regions);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto
        CommandBuffer::copyImage(const IsImage auto&           src,
                                 const IsImage auto&           dst,
                                 ImageLayout                   src_layout,
                                 ImageLayout                   dst_layout,
                                 const ImageSubresourceLayers& src_subresource_layers,
                                 const ImageSubresourceLayers& dst_subresource_layers,
                                 const math::ExtentU&          extent) -> void {
        expects(m_state == State::Recording);

        const auto vk_src_subresource_layers = vk::ImageSubresourceLayers {
            .aspectMask     = narrow<vk::ImageAspectFlagBits>(src_subresource_layers.aspect_mask),
            .mipLevel       = src_subresource_layers.mip_level,
            .baseArrayLayer = src_subresource_layers.base_array_layer,
            .layerCount     = src_subresource_layers.layer_count
        };

        const auto vk_dst_subresource_layers = vk::ImageSubresourceLayers {
            .aspectMask     = narrow<vk::ImageAspectFlagBits>(dst_subresource_layers.aspect_mask),
            .mipLevel       = dst_subresource_layers.mip_level,
            .baseArrayLayer = dst_subresource_layers.base_array_layer,
            .layerCount     = dst_subresource_layers.layer_count
        };

        const auto vk_regions =
            std::array { vk::ImageCopy { .srcSubresource = vk_src_subresource_layers,
                                         .dstSubresource = vk_dst_subresource_layers,
                                         .extent         = as<vk::Extent3D>(extent) } };

        m_vk_command_buffer.copyImage(toVkHandle(src),
                                      narrow<vk::ImageLayout>(src_layout),
                                      toVkHandle(dst),
                                      narrow<vk::ImageLayout>(dst_layout),
                                      vk_regions);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto
        CommandBuffer::resolveImage(const IsImage auto&           src,
                                    const IsImage auto&           dst,
                                    ImageLayout                   src_layout,
                                    ImageLayout                   dst_layout,
                                    const ImageSubresourceLayers& src_subresource_layers,
                                    const ImageSubresourceLayers& dst_subresource_layers) -> void {
        expects(m_state == State::Recording);

        const auto vk_extent = as<vk::Extent3D>(dst.extent());

        const auto vk_src_subresource_layers = vk::ImageSubresourceLayers {
            .aspectMask     = narrow<vk::ImageAspectFlagBits>(src_subresource_layers.aspect_mask),
            .mipLevel       = src_subresource_layers.mip_level,
            .baseArrayLayer = src_subresource_layers.base_array_layer,
            .layerCount     = src_subresource_layers.layer_count
        };

        const auto vk_dst_subresource_layers = vk::ImageSubresourceLayers {
            .aspectMask     = narrow<vk::ImageAspectFlagBits>(dst_subresource_layers.aspect_mask),
            .mipLevel       = dst_subresource_layers.mip_level,
            .baseArrayLayer = dst_subresource_layers.base_array_layer,
            .layerCount     = dst_subresource_layers.layer_count
        };

        const auto vk_regions =
            std::array { vk::ImageResolve { .srcSubresource = vk_src_subresource_layers,
                                            .dstSubresource = vk_dst_subresource_layers,
                                            .extent         = vk_extent } };

        m_vk_command_buffer.resolveImage(toVkHandle(src),
                                         narrow<vk::ImageLayout>(src_layout),
                                         toVkHandle(dst),
                                         narrow<vk::ImageLayout>(dst_layout),
                                         vk_regions);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto CommandBuffer::blitImage(const IsImage auto&         src,
                                                        const IsImage auto&         dst,
                                                        ImageLayout                 src_layout,
                                                        ImageLayout                 dst_layout,
                                                        std::span<const BlitRegion> regions,
                                                        Filter filter) -> void {
        expects(m_state == State::Recording);

        const auto vk_regions =
            regions | std::views::transform([](auto&& region) noexcept {
                const auto vk_src_subresource_layers = vk::ImageSubresourceLayers {
                    .aspectMask     = narrow<vk::ImageAspectFlagBits>(region.src.aspect_mask),
                    .mipLevel       = region.src.mip_level,
                    .baseArrayLayer = region.src.base_array_layer,
                    .layerCount     = region.src.layer_count
                };

                const auto vk_dst_subresource_layers = vk::ImageSubresourceLayers {
                    .aspectMask     = narrow<vk::ImageAspectFlagBits>(region.dst.aspect_mask),
                    .mipLevel       = region.dst.mip_level,
                    .baseArrayLayer = region.dst.base_array_layer,
                    .layerCount     = region.dst.layer_count
                };

                return vk::ImageBlit {
                    .srcSubresource = vk_src_subresource_layers,
                    .srcOffsets     = std::array { as<vk::Offset3D>(region.src_offset[0]),
                                               as<vk::Offset3D>(region.src_offset[1]) },
                    .dstSubresource = vk_dst_subresource_layers,
                    .dstOffsets     = std::array { as<vk::Offset3D>(region.dst_offset[0]),
                                               as<vk::Offset3D>(region.dst_offset[1]) },
                };
            }) |
            std::ranges::to<std::vector>();

        m_vk_command_buffer.blitImage(toVkHandle(src),
                                      narrow<vk::ImageLayout>(src_layout),
                                      toVkHandle(dst),
                                      narrow<vk::ImageLayout>(dst_layout),
                                      vk_regions,
                                      narrow<vk::Filter>(filter));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto CommandBuffer::transitionImageLayout(
        const IsImage auto&          image,
        ImageLayout                  src_layout,
        ImageLayout                  dst_layout,
        const ImageSubresourceRange& subresource_range) -> void {
        expects(m_state == State::Recording);

        const auto vk_src_layout = narrow<vk::ImageLayout>(src_layout);
        const auto vk_dst_layout = narrow<vk::ImageLayout>(dst_layout);

        const auto& src_access = old_layout_access_map.find(vk_src_layout);
        const auto& dst_access = new_layout_access_map.find(vk_dst_layout);

        const auto src_stage = src_access->second.second;
        const auto dst_stage = dst_access->second.second;

        const auto vk_subresource_range = vk::ImageSubresourceRange {
            .aspectMask     = narrow<vk::ImageAspectFlagBits>(subresource_range.aspect_mask),
            .baseMipLevel   = subresource_range.base_mip_level,
            .levelCount     = subresource_range.level_count,
            .baseArrayLayer = subresource_range.base_array_layer,
            .layerCount     = subresource_range.layer_count,
        };

        const auto barriers =
            std::array { vk::ImageMemoryBarrier { .srcAccessMask       = src_access->second.first,
                                                  .dstAccessMask       = dst_access->second.first,
                                                  .oldLayout           = vk_src_layout,
                                                  .newLayout           = vk_dst_layout,
                                                  .srcQueueFamilyIndex = vk::QueueFamilyIgnored,
                                                  .dstQueueFamilyIndex = vk::QueueFamilyIgnored,
                                                  .image               = toVkHandle(image),
                                                  .subresourceRange    = vk_subresource_range } };

        m_vk_command_buffer.pipelineBarrier(src_stage, dst_stage, {}, {}, {}, barriers);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto CommandBuffer::pipelineBarrier(
        PipelineStageFlag                    src_mask,
        PipelineStageFlag                    dst_mask,
        DependencyFlag                       dependency,
        std::span<const MemoryBarrier>       memory_barriers,
        std::span<const BufferMemoryBarrier> buffer_memory_barriers,
        std::span<const ImageMemoryBarrier>  image_memory_barriers) -> void {
        const auto vk_memory_barriers =
            memory_barriers | std::views::transform([](auto&& barrier) noexcept -> decltype(auto) {
                return vk::MemoryBarrier {
                    .srcAccessMask = narrow<vk::AccessFlagBits>(barrier.src),
                    .dstAccessMask = narrow<vk::AccessFlagBits>(barrier.dst),
                };
            }) |
            std::ranges::to<std::vector>();

        const auto vk_buffer_memory_barriers =
            buffer_memory_barriers |
            std::views::transform([](auto&& barrier) noexcept -> decltype(auto) {
                return vk::BufferMemoryBarrier {
                    .srcAccessMask       = narrow<vk::AccessFlagBits>(barrier.src),
                    .dstAccessMask       = narrow<vk::AccessFlagBits>(barrier.dst),
                    .srcQueueFamilyIndex = barrier.src_queue_family_index,
                    .dstQueueFamilyIndex = barrier.dst_queue_family_index,
                    .buffer              = toVkHandle(barrier.buffer),
                    .offset              = barrier.offset,
                    .size                = barrier.size
                };
            }) |
            std::ranges::to<std::vector>();

        const auto vk_image_memory_barriers =
            image_memory_barriers |
            std::views::transform([](auto&& barrier) noexcept -> decltype(auto) {
                const auto vk_subresource_range = vk::ImageSubresourceRange {
                    .aspectMask     = narrow<vk::ImageAspectFlagBits>(barrier.range.aspect_mask),
                    .baseMipLevel   = barrier.range.base_mip_level,
                    .levelCount     = barrier.range.level_count,
                    .baseArrayLayer = barrier.range.base_array_layer,
                    .layerCount     = barrier.range.layer_count
                };

                return vk::ImageMemoryBarrier {
                    .srcAccessMask       = narrow<vk::AccessFlagBits>(barrier.src),
                    .dstAccessMask       = narrow<vk::AccessFlagBits>(barrier.dst),
                    .oldLayout           = narrow<vk::ImageLayout>(barrier.old_layout),
                    .newLayout           = narrow<vk::ImageLayout>(barrier.new_layout),
                    .srcQueueFamilyIndex = barrier.src_queue_family_index,
                    .dstQueueFamilyIndex = barrier.dst_queue_family_index,
                    .image               = toVkHandle(barrier.image),
                    .subresourceRange    = vk_subresource_range
                };
            }) |
            std::ranges::to<std::vector>();

        m_vk_command_buffer.pipelineBarrier(narrow<vk::PipelineStageFlagBits>(src_mask),
                                            narrow<vk::PipelineStageFlagBits>(dst_mask),
                                            narrow<vk::DependencyFlagBits>(dependency),
                                            vk_memory_barriers,
                                            vk_buffer_memory_barriers,
                                            vk_image_memory_barriers);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto CommandBuffer::pushConstants(const PipelineLayout& pipeline_layout,
                                                            ShaderStageFlag       stage,
                                                            std::span<const Byte> data,
                                                            UInt32                offset) -> void {
        expects(m_state == State::Recording);
        expects(not std::empty(data));

        m_vk_command_buffer.pushConstants<const Byte>(toVkHandle(pipeline_layout),
                                                      narrow<vk::ShaderStageFlagBits>(stage),
                                                      offset,
                                                      data);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto CommandBuffer::executeSubCommandBuffers(
        std::span<const Borrowed<const CommandBuffer>> commandbuffers) -> void {
        expects(m_state == State::Recording);

        constexpr auto expectsSecondary = [](auto&& cmb) noexcept -> decltype(auto) {
            expects(cmb->level() == CommandBufferLevel::Secondary);
            return cmb;
        };

        const auto vk_command_buffers =
            commandbuffers |
            std::views::transform(core::monadic::map(expectsSecondary, monadic::toVkHandle())) |
            std::ranges::to<std::vector>();

        m_vk_command_buffer.executeCommands(vk_command_buffers);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto
        CommandBuffer::vkHandle() const noexcept -> const vk::raii::CommandBuffer& {
        return m_vk_command_buffer;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE CommandPool::CommandPool(const Device& device, const Queue& queue, Tag) {
        device.vkHandle()
            .createCommandPool(vk::CommandPoolCreateInfo {
                .flags = vk::CommandPoolCreateFlagBits::eTransient |
                         vk::CommandPoolCreateFlagBits::eResetCommandBuffer })
            .transform(core::monadic::set(m_vk_command_pool))
            .transform_error(core::monadic::map(core::monadic::as<Result>(), throwError()));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE CommandPool::~CommandPool() = default;

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE CommandPool::CommandPool(CommandPool&&) noexcept = default;

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto
        CommandPool::operator=(CommandPool&&) noexcept -> CommandPool& = default;

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto
        CommandPool::create(const Device& device,
                            const Queue&  queue) noexcept -> Expected<CommandPool> try {
        return CommandPool { device, queue, Tag {} };
    } catch (const Result& result) { return std::unexpected(result); }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto CommandPool::allocate(const Device& device,
                                                     const Queue&  queue) noexcept
        -> Expected<std::unique_ptr<CommandPool>> try {
        return std::make_unique<CommandPool>(device, queue, Tag {});
    } catch (const Result& result) { return std::unexpected(result); }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto
        CommandPool::createCommandBuffer(const Device&      device,
                                         CommandBufferLevel level) const noexcept -> CommandBuffer {
        return std::move(createCommandBuffers(device, 1, level).front());
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto CommandPool::createCommandBuffers(
        const Device&      device,
        RangeExtent        count,
        CommandBufferLevel level) const noexcept -> std::vector<CommandBuffer> {
        return createVkCommandBuffers(device, count, level) | std::views::as_rvalue |
               std::views::transform(
                   [this, &level](vk::raii::CommandBuffer&& cmb) noexcept -> decltype(auto) {
                       return CommandBuffer::create(*this,
                                                    level,
                                                    std::move(cmb),
                                                    curry(&CommandPool::deleteVkCommandBuffer,
                                                          const_cast<CommandPool*>(this)));
                   }) |
               std::ranges::to<std::vector>();
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto CommandPool::allocateCommandBuffer(
        const Device&      device,
        CommandBufferLevel level) const noexcept -> std::unique_ptr<CommandBuffer> {
        return std::move(allocateCommandBuffers(device, 1, level).front());
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto CommandPool::allocateCommandBuffers(
        const Device&      device,
        RangeExtent        count,
        CommandBufferLevel level) const noexcept -> std::vector<std::unique_ptr<CommandBuffer>> {
        return createVkCommandBuffers(device, count, level) | std::views::as_rvalue |
               std::views::transform(
                   [this, &level](vk::raii::CommandBuffer&& cmb) noexcept -> decltype(auto) {
                       return CommandBuffer::allocate(*this,
                                                      level,
                                                      std::move(cmb),
                                                      curry(&CommandPool::deleteVkCommandBuffer,
                                                            const_cast<CommandPool*>(this)));
                   }) |
               std::ranges::to<std::vector>();
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto
        CommandPool::vkHandle() const noexcept -> const vk::raii::CommandPool& {
        return m_vk_command_pool;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto
        CommandPool::deleteVkCommandBuffer(vk::raii::CommandBuffer& cmb) noexcept -> void {
        // auto lock = std::unique_lock { m_reuse_mutex };
        // m_reusable_command_buffers.emplace_back(std::move(cmb));
    }
} // namespace stormkit::gpu
